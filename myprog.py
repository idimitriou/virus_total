import os
import subprocess
import urllib.request
import zipfile
import datetime
import platform
import socket
from pathlib import Path
import csv
import codecs
import requests
import time
from time import sleep
import json
import argparse

def curr_time():
	return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def download_autoruns(v):
	if v: print('\nDownload latest version of autoruns...')

	url = 'https://download.sysinternals.com/files/Autoruns.zip'
	urllib.request.urlretrieve(url, './Autoruns.zip')

	if v: print('uzip autoruns...')

	zip_ref = zipfile.ZipFile('./Autoruns.zip', 'r')
	zip_ref.extractall('./Autoruns')
	zip_ref.close()

	if v: print('delete initial zip file...')

	os.remove('./Autoruns.zip')

def run_autoruns(v):
	ROOT_PATH	 = Path(__file__).parent
	SYS_ARCH	 = platform.machine() # AMD64 or x86
	cmd_name	 = 'autorunsc.exe' if SYS_ARCH == 'x86' else 'autorunsc64.exe'
	csv_name	 = 'autoruns.csv'

	if os.path.isfile(str(ROOT_PATH / 'Autoruns' / (cmd_name))) is False:
		print('\nERROR!\nAutoruns path does not exist. Try with arg [-d] to download latest version.\n\n')
		exit(0)

	if v: print('\ncreate csv with autoruns...')
	cmd			 = str(ROOT_PATH / 'Autoruns' / (cmd_name)) + ' -c -s -h -m -a -nobanner * /accepteula > ' + csv_name

	if v: print('run command: ' + cmd + ' at: ' + curr_time())

	os.system(cmd)

	if v: print('ended at: ' + curr_time())
	return csv_name

def parse_csv(csvread,v,c):
	already_done = []
	results		 = []
	for row in csvread:
		try:
			if row[16] != 'SHA-256' and row[16] != '' and row[16] not in already_done:
				res = do_the_call(row[16],v,1)
				if(res != ''):
					tmp = print_results(res.json())
					if(tmp[1] == 0 and v): print('\n	--->' + repr(row[1]) + '[' + repr(row[1]) + ']: clean!')
					elif(tmp[1] != 0):
						print('\n--->' + repr(row[1]) + '[' + repr(row[1]) + '] ' + ': ' + repr(tmp[1]) + '/' + repr(tmp[2]))
						results.append([row[1],row[2],row[16],tmp])
				elif v: print('\nrequest failed...')
				already_done.append(row[16])
		except Exception as e: 
			if v: print(e)
	if c:
		ROOT_PATH	 = Path(__file__).parent
		tmstmp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
		dir_save = str(ROOT_PATH / ('results-'+ tmstmp +'.csv'))
		writer = open(dir_save, "w")
		columnTitleRow = "Entry Location,Entry,SHA-256,positives,detected from\n"
		writer.write(columnTitleRow)
		for i in results:
			row = i[0] + "," + i[1] + "," + i[2] + "," + repr(i[3][1]) + ' / ' + repr(i[3][2]) + ","
			for j in i[3][0]:
				row += j[0] + ' [' + j[1] + '],'
			row += "\n"
			writer.write(row)
		writer.close()
		print('\n[!] Results saved in: ' + repr(dir_save))

def do_the_call(hash,v,retries):
	api_key			= 'dae2b93c2e6d86910f5df826c251b75f06c177158252acd0c41830649fb6b1ca'
	vt_url			= 'https://www.virustotal.com/vtapi/v2/file/scan'
	vt_report_url	= 'https://www.virustotal.com/vtapi/v2/file/report'
	headers			= {
		"Accept-Encoding"	: "gzip, deflate",
		"User-Agent" 		: "gzip, idimitriou"
	}
	if v: print('\nInvestigate hash('+repr(hash)+') try: '+repr(retries))
	if(retries == 6): return ''
	params = {'apikey': api_key, 'resource': hash}
	try:
		response = requests.get(vt_report_url,params=params, headers=headers)
		if response.status_code == 204:
			if v: print('\n[!] VirusTotal Rate Limit Exceeded. Sleeping for 60 seconds...')
			time.sleep(60)
			retries+=1
			do_the_call(hash,v,retries)
		else: 
			time.sleep(15)
			return response
	except requests.exceptions.ConnectionError:
		if v: print('\n[!] Connection Error occured. Trying again...')
		retries+=1
		do_the_call(hash,v,retries)

def print_results(res):
	detected = []
	if res['positives'] != 0:
		for scans, attrs in res['scans'].items():
			for nm, vl in attrs.items():
				if nm == 'detected' and vl == True:
					detected.append([scans,attrs['result']])
	return [detected,res['positives'],res['total']]

def main():
	parser = argparse.ArgumentParser(description='parse a csv file generated by autoruns and print the malicious entries based on virustotal ranking.')
	parser.add_argument("-v","--verbose"	, help="Print verbose messages"				 , action="store_true")
	parser.add_argument("-d","--download"	, help="Download latest version of autoruns" , action="store_true")
	parser.add_argument("-r","--run"		, help="Run autoruns" 						 , action="store_true")
	parser.add_argument("-i","--input"		, help="Feed the script with your own autoruns.csv. If arg -r is set this option will be ignored.")
	parser.add_argument("-c","--csv"		, help="Save results in csv format."		 , action="store_true")

	args = parser.parse_args()

	v = True if args.verbose else False
	c = True if args.csv	 else False

	if v: print('process started for '+repr(socket.gethostname())+' at: ' + curr_time())

	if args.download: download_autoruns(v)
	if args.run: 
		csv_name = run_autoruns(v)
	elif args.input != None:
		ROOT_PATH	 = Path(__file__).parent

		if os.path.isfile(str(ROOT_PATH / (args.input))) is False:
			print('\nERROR!\ncsv file ['+repr(args.input)+'] does not exist. Try with arg [-r] to create a new csv file with autoruns.\n\n')
			exit(0)
		else:
			csv_name = args.input
	else:
		print('\nERROR!\nNo csv file detected. Try with arg [-r] to create a new csv file with autoruns or feed the script with arg [-i].\n\n')
		exit(0)

	f=codecs.open(csv_name,"rb","utf-16")
	csvread=csv.reader(f,delimiter=',')

	parse_csv(csvread,v,c)
	if v: print('process ended at: ' + curr_time())

if __name__ == '__main__':
	main()